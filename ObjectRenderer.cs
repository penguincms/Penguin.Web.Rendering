using Microsoft.AspNetCore.Hosting;
using Penguin.Entities.Abstractions;
using Penguin.Extensions.String;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace Penguin.Cms.Web.Rendering
{
    /// <summary>
    /// A base class for rendering out an instance of an entity into a compilable MVC view using a template
    /// To facilitate object binding and HTML generation for dynamic pages and email templates without needing to use 
    /// reflection based binding
    /// </summary>
    public class ObjectRenderer
    {
        internal const string AUTOGENERATED_TAG = "@*Everything above this line is autogenerated. If you change it, you will lose your changes.*@";
        internal const string TUPLE_NOTE = "@*System.ValueTuple requires at least two types so all templates have a value model to match that requirement. You can ignore placeholder elements*@";
        internal static object TemplateLock = new object();

        internal IHostingEnvironment HostingEnvironment { get; set; }

        /// <summary>
        /// Small class used to hold parameter information in a way that is not 
        /// reliant on the source (Method/Template)
        /// </summary>
        protected class ParameterMeta
        {
            /// <summary>
            /// The name of the parameter
            /// </summary>
            public string Name { get; set; }

            /// <summary>
            /// The intended type of the parameter
            /// </summary>
            public Type ParameterType { get; set; }

            /// <summary>
            /// Constructs a new instance of this class using the supplied information
            /// </summary>
            /// <param name="name">The name of the parameter</param>
            /// <param name="parameterType"> The intended type of the parameter</param>
            public ParameterMeta(string name, Type parameterType)
            {
                this.ParameterType = parameterType;
                this.Name = name;
            }
        }

        /// <summary>
        /// Constructs a new instance of the Object Renderer
        /// </summary>
        /// <param name="hostingEnvironment">The IHosting environment used to determine the path the Templates should be rendered to (Views/Cache)</param>
        public ObjectRenderer(IHostingEnvironment hostingEnvironment)
        {
            this.HostingEnvironment = hostingEnvironment;
        }

        /// <summary>
        /// Takes the supplied parameter values and constructs a Tuple that represents the parameters to use as the model for generating the page
        /// </summary>
        /// <param name="ParameterValues">The values to set the parameters to for the Tuple being generated</param>
        /// <param name="TemplateParameters">The intended parameters for the new page</param>
        /// <returns>A Tuple representing the Model as defined for the new dynamically generated view</returns>
        protected object BuildPageModel(Dictionary<string, object> ParameterValues, List<ParameterMeta> TemplateParameters)
        {
            int i = 0;
            while (TemplateParameters.Count < 2)
            {
                string name = "PlaceHolder" + (++i).ToString();
                ParameterValues.Add(name, new object());
                TemplateParameters.Add(new ParameterMeta(name, typeof(object)));
            }

            List<object> buildValues = new List<object>();

            foreach (ParameterMeta param in TemplateParameters)
            {
                if (ParameterValues.ContainsKey(param.Name))
                {
                    buildValues.Add(ParameterValues[param.Name]);
                }
                else if (param.ParameterType.IsValueType)
                {
                    buildValues.Add(Activator.CreateInstance(param.ParameterType));
                }
                else
                {
                    buildValues.Add(null);
                }
            }

            return this.CreateTuple(TemplateParameters, buildValues);
        }

        /// <summary>
        /// Constructs a Tuple with the intent of passing into a dynamically generated view for rendering
        /// </summary>
        /// <param name="Parameters">A list of parameters defining the object structure of the model</param>
        /// <param name="values">A list of values for the previous listed parameters, with matching indexes</param>
        /// <returns>A tuple representing an instance of a model to pass into a dynamically generated view</returns>
        protected object CreateTuple(IEnumerable<ParameterMeta> Parameters, IEnumerable<object> values)
        {
            Type tupleType = Type.GetType("System.ValueTuple`" + Parameters.Count())?.MakeGenericType(Parameters.Select(p => p.ParameterType).ToArray());

            if (tupleType is null)
            {
                throw new Exception("Tuple type is null. This will probably be the case if we're not getting it from mscorelib anymore so code to account for that");
            }

            return Activator.CreateInstance(tupleType, values.ToArray());
        }

        /// <summary>
        /// Takes the supplied object and generates a view path based on its Auditable entity properties
        /// </summary>
        /// <param name="e">The Auditable entity to generate the view based off of.Uses the ID/Guid and the DateModified to determine if the template needs to be updated</param>
        /// <param name="ParameterValues">A list of property names and values to use to build the page model for the dynamically generated page</param>
        /// <param name="TemplateParameters">A list of parameters intended to be possible injection targets, used to build the model definition in the context of the view @model</param>
        /// <param name="TemplateContents">The text string to inject into the template view, the Body of the view beyond what this system generates for injectable model information</param>
        /// <param name="FieldName">The name of the field of the entity that this view is intended to bind against used during path generation </param>
        /// <returns></returns>
        protected (string AbsolutePath, string RelativePath, object Model) GenerateTemplatePath(IAuditableEntity e, Dictionary<string, object> ParameterValues, List<ParameterMeta> TemplateParameters, string TemplateContents, string FieldName = "")
        {
            object model = this.BuildPageModel(ParameterValues, TemplateParameters);

            string RelativePath = Path.Combine("Client", "Views", "Cache", e.GetType().Name, e._Id.ToString(), FieldName, ((e.DateModified.Value - new DateTime(1970, 1, 1)).TotalMilliseconds.ToString()) + ".cshtml");

            string AbsolutePath = Path.Combine(this.HostingEnvironment.ContentRootPath, RelativePath);

            DirectoryInfo CachePath = new FileInfo(AbsolutePath).Directory;

            if (!CachePath.Exists)
            {
                CachePath.Create();
            }

            lock (TemplateLock)
            {
                if (!System.IO.File.Exists(AbsolutePath))
                {
                    string contents = TemplateContents?.ToString() ?? string.Empty;

                    if (!contents.Contains(AUTOGENERATED_TAG))
                    {
                        List<string> Header = new List<string>()
                        {
                            TUPLE_NOTE,
                            $"@model ({string.Join(", ", TemplateParameters.Select(p => $"{GetTypeDisplayName(p.ParameterType)} {p.Name}"))})",
                            AUTOGENERATED_TAG,
                            $"@*{e.Guid}*@"
                        };

                        contents = string.Join(System.Environment.NewLine, Header) + System.Environment.NewLine + System.Environment.NewLine + System.Environment.NewLine + contents;
                    }

                    System.IO.File.WriteAllText(AbsolutePath, contents);
                }
            }

            return (AbsolutePath, RelativePath, model);
        }

        /// <summary>
        /// Converts a Type into a string represention of that type that one would see when actually coding for that type
        /// </summary>
        /// <param name="type">The type to stringify</param>
        /// <returns>The actual code text that would be used to reference that type</returns>
        public string GetTypeDisplayName(Type type)
        {
            if (!type.GetGenericArguments().Any())
            {
                return type.FullName;
            }
            else
            {
                StringBuilder sb = new StringBuilder();

                sb.Append(type.FullName.To("`"));

                sb.Append("<");

                sb.Append(string.Join(",", type.GetGenericArguments().Select(t => GetTypeDisplayName(t))));

                sb.Append(">");

                return sb.ToString();
            }
        }

    }
}
